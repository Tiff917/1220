<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Comments</title>
    <style>
        /* --- 基礎設定 --- */
        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
        
        /* ★★★ 關鍵修改區：禁止左右滑動設定 ★★★ */
        html, body {
            width: 100%;
            height: 100vh;
            overflow-x: hidden;          /* 隱藏水平捲軸，防止內容溢出 */
            overscroll-behavior-x: none; /* 禁止瀏覽器預設的「水平滑動」行為 (例如滑動回上一頁) */
        }

        body { 
            background-color: white; 
            position: fixed; /* 【關鍵】將 body 釘死在畫面上，徹底根除 iOS 回彈 */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            color: #262626; 
            display: flex;
            overflow: hidden; /* 鎖死 body 捲軸 */
            touch-action: pan-y; /* 【關鍵】告訴瀏覽器：這裡只允許「垂直」滑動，忽略水平手勢 */
            flex-direction: column;
        }

        /* 頂部導航列 */
        .header {
            height: 50px; border-bottom: 1px solid #dbdbdb;
            display: flex; align-items: center; padding: 0 16px;
            font-weight: 600; font-size: 16px; justify-content: space-between;
            background: white; flex-shrink: 0;
            width: 100%; /* 確保滿版 */
        }
        .back-btn { cursor: pointer; display: flex; align-items: center; justify-content: center; width: 30px; height: 30px;}
        
        /* 留言列表區 */
        .content { 
            flex: 1; 
            overflow-y: auto;       /* 允許垂直滑動 */
            overflow-x: hidden;     /* 禁止內容區水平滑動 */
            padding: 16px; 
            overscroll-behavior-y: contain; 
            -webkit-overflow-scrolling: touch; /* 讓 iOS 捲動保持順暢 */
            width: 100%;
        }
        
        /* 第一則留言 (Caption) */
        .caption-block { display: flex; gap: 12px; padding-bottom: 12px; border-bottom: 1px solid #efefef; margin-bottom: 12px; }
        .caption-avatar { width: 32px; height: 32px; border-radius: 50%; object-fit: cover; background: #dbdbdb; flex-shrink: 0; }
        
        /* ★★★ 加入 word-break 防止長文字撐開頁面 ★★★ */
        .caption-text-area { 
            flex: 1; font-size: 14px; line-height: 1.4; 
            word-break: break-word; /* 強制長單字斷行 */
        }
        
        /* 一般留言 */
        .comment-row { display: flex; gap: 12px; margin-bottom: 16px; }
        .comment-avatar { width: 32px; height: 32px; border-radius: 50%; object-fit: cover; background: #dbdbdb; flex-shrink: 0; }
        .comment-user { font-weight: 600; margin-right: 5px; }
        
        /* ★★★ 加入 word-break 防止長文字撐開頁面 ★★★ */
        .comment-text-block { 
            font-size: 14px; line-height: 1.4; 
            flex: 1; /* 確保文字區塊佔滿剩餘空間 */
            word-break: break-word; /* 強制長單字斷行 */
            min-width: 0; /* Flexbox 換行小技巧，防止溢出 */
        }

        .time-text { font-size: 12px; color: #8e8e8e; margin-top: 4px; display: block; }

        /* 底部輸入框 */
        .footer {
            border-top: 1px solid #dbdbdb; padding: 10px 16px;
            display: flex; align-items: center; background: white;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            flex-shrink: 0;
            width: 100%;
        }
        .user-avatar-small { width: 32px; height: 32px; border-radius: 50%; margin-right: 12px; object-fit: cover; background: #dbdbdb;}
        .comment-input { flex: 1; border: none; font-size: 14px; padding: 8px 0; background: transparent; }
        .post-btn { color: #bfa093; font-weight: 600; font-size: 14px; border: none; background: none; cursor: pointer; padding-left: 10px; opacity: 0.5; pointer-events: none; }
        .post-btn.active { opacity: 1; pointer-events: auto; }
    </style>
</head>
<body>

    <div class="header">
        <div class="back-btn" onclick="window.history.back()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
        </div>
        <span>Comments</span>
        <div style="width: 30px;"></div>
    </div>

    <div class="content" id="comments-list">
        <div style="text-align:center; margin-top:50px; color:#999;">Loading...</div>
    </div>

    <div class="footer">
        <img src="" class="user-avatar-small" id="my-avatar">
        <input type="text" class="comment-input" id="input-box" placeholder="Add a comment..." autocomplete="off">
        <button class="post-btn" id="post-btn">Post</button>
    </div>

<script>
        const dbName = "MemoriesDB";
        let db;
        // 預設頭像
        let userAvatarUrl = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        let currentPost = null;
        let postId = null;

        // --- 1. 抓取網址 ID 並檢查 ---
        const params = new URLSearchParams(window.location.search);
        const idParam = params.get('id');
        
        // 這裡很重要：如果 feed.html 傳過來的 ID 是數字，這裡就要轉數字
        // 如果發現一直讀不到，試著把 parseInt 拿掉改成： postId = idParam;
        postId = idParam ? parseInt(idParam) : null;

        console.log("目前的 Post ID 是:", postId); // 在 F12 Console 顯示

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 6);
                request.onsuccess = (e) => { db = e.target.result; resolve(db); };
                request.onerror = (e) => {
                    alert("資料庫開啟失敗");
                    reject(e);
                };
            });
        }

        async function init() {
            // ★ 防呆 1：如果網址沒有 ?id=xxx，直接警告
            if (!postId) {
                document.getElementById('comments-list').innerHTML = '<div style="text-align:center; margin-top:50px;">錯誤：網址缺少貼文 ID<br>請從首頁重新進入</div>';
                return;
            }

            await initDB();
            loadUserProfile();
            loadPostData();
        }

        function loadUserProfile() {
            const tx = db.transaction("user_profile", "readonly");
            const req = tx.objectStore("user_profile").get("avatar");
            req.onsuccess = (e) => {
                const res = e.target.result;
                if (res && (res instanceof Blob || res instanceof File)) {
                    userAvatarUrl = URL.createObjectURL(res);
                }
                document.getElementById('my-avatar').src = userAvatarUrl;
                // 如果已經讀取到貼文，就更新頭像顯示
                if (currentPost) renderComments();
            };
        }

        function loadPostData() {
            const tx = db.transaction("posts_timeline", "readonly");
            const store = tx.objectStore("posts_timeline");
            const request = store.get(postId);

            request.onsuccess = (e) => {
                currentPost = e.target.result;
                
                if (currentPost) {
                    console.log("成功讀取貼文:", currentPost);
                    // 確保陣列存在
                    if (!currentPost.comments) {
                        currentPost.comments = [];
                    }
                    renderComments();
                } else {
                    console.log("找不到 ID 為", postId, "的貼文");
                    // ★ 防呆 2：資料庫裡找不到這則貼文
                    document.getElementById('comments-list').innerHTML = '<div style="text-align:center; margin-top:50px;">這則貼文似乎已被刪除</div>';
                    // 讓 currentPost 保持 null，這樣按鈕點擊時會觸發警告
                    currentPost = null; 
                }
            };
            
            request.onerror = (e) => {
                console.error("讀取貼文失敗", e);
                alert("讀取資料失敗");
            };
        }

        function renderComments() {
            const list = document.getElementById('comments-list');
            const storedName = localStorage.getItem('myProfileName');
            const myName = storedName ? storedName : "Me";

            const comments = currentPost.comments || [];

            // ★ 注意：這裡的邏輯是「第 1 則留言 = 貼文標題 (Caption)」
            // 所以如果您發了第一則留言，它會出現在「最上面」，而不是下面的列表
            let captionText = (comments.length > 0) ? comments[0].text : "<span style='color:#999; font-style:italic;'>(無標題)</span>";
            
            // 渲染上半部 (標題區)
            let html = `
                <div class="caption-block">
                    <img src="${userAvatarUrl}" class="caption-avatar">
                    <div class="caption-text-area">
                        <span class="comment-user">${myName}</span>
                        <span>${captionText}</span>
                        <div class="time-text">${new Date(currentPost.timestamp).toDateString()}</div>
                    </div>
                </div>
            `;

            // 渲染下半部 (留言列表，從第 2 則開始)
            if (comments.length > 1) {
                for (let i = 1; i < comments.length; i++) {
                    const c = comments[i];
                    // 判斷頭像
                    let avatarSrc = (c.user === myName) ? userAvatarUrl : `https://i.pravatar.cc/150?u=${c.user}`;
                    
                    html += `
                        <div class="comment-row">
                            <img src="${avatarSrc}" class="comment-avatar">
                            <div class="comment-text-block">
                                <span class="comment-user">${c.user}</span>
                                <span>${c.text}</span>
                            </div>
                        </div>
                    `;
                }
            } else if (comments.length === 1) {
                // 如果只有 1 則留言 (剛發的)，它變成了標題，下面會是空的
                // 這裡可以不顯示東西，或者顯示 "尚無其他留言"
                html += `<div style="text-align:center; color:#ddd; font-size:12px; margin-top:20px;">尚無其他留言</div>`;
            } else {
                 html += `<div style="text-align:center; color:#ddd; font-size:12px; margin-top:20px;">尚無內容</div>`;
            }

            list.innerHTML = html;
            
            // 自動捲動到底部
            setTimeout(() => {
                list.scrollTop = list.scrollHeight;
            }, 50);
        }

        const input = document.getElementById('input-box');
        const btn = document.getElementById('post-btn');

        // 輸入框監聽：有字才亮燈
        input.oninput = () => {
            if (input.value.trim().length > 0) btn.classList.add('active');
            else btn.classList.remove('active');
        };

        btn.onclick = submitComment;
        input.onkeypress = (e) => { if (e.key === 'Enter') submitComment(); };

        function submitComment() {
            const text = input.value.trim();
            
            // ★ 防呆 3：按鈕點擊後的診斷
            if (!currentPost) {
                alert("錯誤：系統還沒抓到這則貼文，無法留言。\n可能原因：網址 ID 錯誤或資料庫已清空。");
                return;
            }
            if (!text) {
                return; // 內容為空不理會
            }

            const storedName = localStorage.getItem('myProfileName');
            const myName = storedName ? storedName : "Me";

            // 確保陣列存在
            if (!currentPost.comments) {
                currentPost.comments = [];
            }

            // 1. 推入資料
            currentPost.comments.push({ user: myName, text: text });
            console.log("準備寫入留言:", text);

            // 2. 寫入資料庫
            const tx = db.transaction(["posts_timeline"], "readwrite");
            const store = tx.objectStore("posts_timeline");
            const request = store.put(currentPost);

            request.onsuccess = () => {
                console.log("寫入成功！");
                // 3. 成功後清空介面
                input.value = '';
                btn.classList.remove('active');
                
                // 4. 重新渲染畫面 (這時候應該要看到新留言)
                renderComments();
            };
            
            request.onerror = (e) => {
                console.error("寫入失敗", e);
                alert("留言發布失敗，請查看 Console 錯誤訊息");
            };
        }

        init();
    </script>
</body>
</html>
